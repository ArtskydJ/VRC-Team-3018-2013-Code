#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    SpatulaPotentiometer, sensorNone)
#pragma config(Sensor, in2,    LiftPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in3,    AutoSelector,   sensorPotentiometer)
#pragma config(Sensor, in4,    RightLineFollower, sensorLineFollower)
#pragma config(Sensor, in5,    LeftLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    LeftLineEdgeDetector, sensorLineFollower)
#pragma config(Sensor, in7,    Gyro,           sensorGyro)
#pragma config(Sensor, in8,    RightLineEdgeDetector, sensorLineFollower)
#pragma config(Sensor, dgtl1,  BackRightQuad,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  ConveyerSwitch, sensorTouch)
#pragma config(Sensor, dgtl4,  BackSideUltrasonic, sensorSONAR_mm)
#pragma config(Sensor, dgtl6,  LeftSideUltrasonic, sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  BackLeftQuad,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, RightSideUltrasonic, sensorSONAR_mm)
#pragma config(Sensor, I2C_1,  BackRightEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  BackLeftEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           DriveBR,       tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           DriveFR,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port3,           Conveyor,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           LiftR,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           DriveBL,       tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port6,           SpatulaR,      tmotorVex393, openLoop)
#pragma config(Motor,  port7,           SpatulaL,      tmotorVex393, openLoop)
#pragma config(Motor,  port8,           Descorer,      tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port9,           DriveFL,       tmotorVex393, openLoop)
#pragma config(Motor,  port10,          LiftL,         tmotorVex393HighSpeed, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Hello there! Welcome to Techna PWN Robotics' ROBOTC code for Theta, Team 3018's 2012-2013 Sack Attack robot. This code was	//
//	based on ideas from Team 3018's 2011-2012 robot Andy's code, and initially formed from the code for	Team 3018's first Sack	//
//	Attack robot, FILSS. It was created by Ryan Plummer, Josiah Krutz, and Joseph Dykstra.										//
//	The main goals we have for our robot's code are ease of use and readability.												//
//	In order to help achieve this, our code is broken up into a rough Sense/Plan/Act structure, and is procedural in nature,	//
//	with the code executing straight through a constant-time loop, not using any tasks or parallel code. This not only allows	//
//	the programmers to debug the code much more easily, but also enables our code to execute in a consistent and predictable	//
//	manner each time it is run. Readability is benefited by our striving to name variables and functions descriptively, and		//
//  through related sections of our code being parted out into different files and #included below, so that the main file can	//
//  remain less cluttered.																										//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/


#define COMPETITION //Comment this out to activate the virtual competition switch variables when using the PC-Based Emulator

#include "Definitions_and_Declarations.c"
#include "Other_Functions.c"
#include "Driver_Control.c"
#include "Input_and_Output.c"
#include "LCD.c"

#include "Driver_Autos.c"
#include "Auto01.c"
#include "Auto02.c"
#include "Auto03.c"
#include "Auto04.c"
#include "Auto05.c"
#include "Auto06.c"
#include "Auto08.c"
#include "Auto09.c"
#include "Auto10.c" //Main Programming Skills Routine
#include "Auto11.c"
#include "Auto12.c"

#include "Autonomous_Structures.c"
#include "Initialization.c"

task main()
{
	InitializePIDControllers();
	InitializeLCDScreen();
	InitializeDebugStream();
	InitializeTimers();
	InitializeEncoders();
	InitializeAutonomousPotentiometer();
	UpdateAutonomousRoutine();
	while(true)
	{
		Input();
		UpdateCustomTimers();
		UpdateAbsoluteGyro();
		if(!IsRobotDisabled) //If the robot isn't disabled
		{
			//Autonomous mode
			if (IsRobotInAutonomousMode || IsRobotInVirtualAutonomousMode ||
				(DriverMode != DriverJoystickControl && DriverMode != DriverMotorTest))
			{
				AutonomousControl();
				LiftTarget = 0;
				UpdateScreen(DispAutonomousMode);
				LogEncoders();
				if (!IsRobotInAutonomousMode)
					if (JoystickActivated(true))
						IsRobotInVirtualAutonomousMode = false;
			}

			else
			//Driver control Mode
			{
				AutonomousStep = 0;
				UpdateAutonomousRoutine();
				UpdateScreen(DispDriverMode);
				if (DriverMode == DriverJoystickControl) //Driver has control
				{
					AutonomousReset(Finish);
					SubroutineCheck();
					DriveControl();
					IntakeControl();
					LiftControl();
					DescorerControl();
				}
				else if (DriverMode == DriverMotorTest) //Motor test has control
				{
					if (JoystickActivated(false)) //Switch back to driver having control if joystick is bumped
						DriverMode = DriverJoystickControl;
				}
			}
		}
		else //If the robot is disabled
		{
			AutonomousStep = 0;
			AutonomousReset(Finish);
			UpdateAutonomousRoutine();
			UpdateScreen(DispDisabledMode);
		}
		Output();
		SoundControl();
		ConstantLoopDelay(); //This allows our main loop to run at a constant rate.
	}
}
